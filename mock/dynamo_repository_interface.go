// Code generated by MockGen. DO NOT EDIT.
// Source: dynamo_repository_interface.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	djoemo "github.com/adjoeio/djoemo"
	gomock "github.com/golang/mock/gomock"
)

// MockRepositoryInterface is a mock of RepositoryInterface interface.
type MockRepositoryInterface struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryInterfaceMockRecorder
}

// MockRepositoryInterfaceMockRecorder is the mock recorder for MockRepositoryInterface.
type MockRepositoryInterfaceMockRecorder struct {
	mock *MockRepositoryInterface
}

// NewMockRepositoryInterface creates a new mock instance.
func NewMockRepositoryInterface(ctrl *gomock.Controller) *MockRepositoryInterface {
	mock := &MockRepositoryInterface{ctrl: ctrl}
	mock.recorder = &MockRepositoryInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryInterface) EXPECT() *MockRepositoryInterfaceMockRecorder {
	return m.recorder
}

// BatchGetItemsWithContext mocks base method.
func (m *MockRepositoryInterface) BatchGetItemsWithContext(ctx context.Context, keys []djoemo.KeyInterface, out interface{}) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BatchGetItemsWithContext", ctx, keys, out)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetItemsWithContext indicates an expected call of BatchGetItemsWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) BatchGetItemsWithContext(ctx, keys, out interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetItemsWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).BatchGetItemsWithContext), ctx, keys, out)
}

// ConditionalUpdate mocks base method.
func (m *MockRepositoryInterface) ConditionalUpdate(key djoemo.KeyInterface, item interface{}, expression string, expressionArgs ...interface{}) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{key, item, expression}
	for _, a := range expressionArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConditionalUpdate", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConditionalUpdate indicates an expected call of ConditionalUpdate.
func (mr *MockRepositoryInterfaceMockRecorder) ConditionalUpdate(key, item, expression interface{}, expressionArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{key, item, expression}, expressionArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConditionalUpdate", reflect.TypeOf((*MockRepositoryInterface)(nil).ConditionalUpdate), varargs...)
}

// ConditionalUpdateWithContext mocks base method.
func (m *MockRepositoryInterface) ConditionalUpdateWithContext(ctx context.Context, key djoemo.KeyInterface, item interface{}, expression string, expressionArgs ...interface{}) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, key, item, expression}
	for _, a := range expressionArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConditionalUpdateWithContext", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConditionalUpdateWithContext indicates an expected call of ConditionalUpdateWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) ConditionalUpdateWithContext(ctx, key, item, expression interface{}, expressionArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, key, item, expression}, expressionArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConditionalUpdateWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).ConditionalUpdateWithContext), varargs...)
}

// ConditionalUpdateWithUpdateExpressionsAndReturnValue mocks base method.
func (m *MockRepositoryInterface) ConditionalUpdateWithUpdateExpressionsAndReturnValue(ctx context.Context, key djoemo.KeyInterface, item interface{}, updateExpressions djoemo.UpdateExpressions, conditionExpression string, conditionArgs ...interface{}) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, key, item, updateExpressions, conditionExpression}
	for _, a := range conditionArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConditionalUpdateWithUpdateExpressionsAndReturnValue", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConditionalUpdateWithUpdateExpressionsAndReturnValue indicates an expected call of ConditionalUpdateWithUpdateExpressionsAndReturnValue.
func (mr *MockRepositoryInterfaceMockRecorder) ConditionalUpdateWithUpdateExpressionsAndReturnValue(ctx, key, item, updateExpressions, conditionExpression interface{}, conditionArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, key, item, updateExpressions, conditionExpression}, conditionArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConditionalUpdateWithUpdateExpressionsAndReturnValue", reflect.TypeOf((*MockRepositoryInterface)(nil).ConditionalUpdateWithUpdateExpressionsAndReturnValue), varargs...)
}

// DeleteItem mocks base method.
func (m *MockRepositoryInterface) DeleteItem(key djoemo.KeyInterface) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteItem", key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteItem indicates an expected call of DeleteItem.
func (mr *MockRepositoryInterfaceMockRecorder) DeleteItem(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteItem", reflect.TypeOf((*MockRepositoryInterface)(nil).DeleteItem), key)
}

// DeleteItemWithContext mocks base method.
func (m *MockRepositoryInterface) DeleteItemWithContext(ctx context.Context, key djoemo.KeyInterface) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteItemWithContext", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteItemWithContext indicates an expected call of DeleteItemWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) DeleteItemWithContext(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteItemWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).DeleteItemWithContext), ctx, key)
}

// DeleteItems mocks base method.
func (m *MockRepositoryInterface) DeleteItems(key []djoemo.KeyInterface) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteItems", key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteItems indicates an expected call of DeleteItems.
func (mr *MockRepositoryInterfaceMockRecorder) DeleteItems(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteItems", reflect.TypeOf((*MockRepositoryInterface)(nil).DeleteItems), key)
}

// DeleteItemsWithContext mocks base method.
func (m *MockRepositoryInterface) DeleteItemsWithContext(ctx context.Context, key []djoemo.KeyInterface) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteItemsWithContext", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteItemsWithContext indicates an expected call of DeleteItemsWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) DeleteItemsWithContext(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteItemsWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).DeleteItemsWithContext), ctx, key)
}

// GIndex mocks base method.
func (m *MockRepositoryInterface) GIndex(name string) djoemo.GlobalIndexInterface {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GIndex", name)
	ret0, _ := ret[0].(djoemo.GlobalIndexInterface)
	return ret0
}

// GIndex indicates an expected call of GIndex.
func (mr *MockRepositoryInterfaceMockRecorder) GIndex(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GIndex", reflect.TypeOf((*MockRepositoryInterface)(nil).GIndex), name)
}

// GetItem mocks base method.
func (m *MockRepositoryInterface) GetItem(key djoemo.KeyInterface, item interface{}) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetItem", key, item)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetItem indicates an expected call of GetItem.
func (mr *MockRepositoryInterfaceMockRecorder) GetItem(key, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItem", reflect.TypeOf((*MockRepositoryInterface)(nil).GetItem), key, item)
}

// GetItemWithContext mocks base method.
func (m *MockRepositoryInterface) GetItemWithContext(ctx context.Context, key djoemo.KeyInterface, item interface{}) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetItemWithContext", ctx, key, item)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetItemWithContext indicates an expected call of GetItemWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) GetItemWithContext(ctx, key, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).GetItemWithContext), ctx, key, item)
}

// GetItems mocks base method.
func (m *MockRepositoryInterface) GetItems(key djoemo.KeyInterface, items interface{}) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetItems", key, items)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetItems indicates an expected call of GetItems.
func (mr *MockRepositoryInterfaceMockRecorder) GetItems(key, items interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItems", reflect.TypeOf((*MockRepositoryInterface)(nil).GetItems), key, items)
}

// GetItemsWithContext mocks base method.
func (m *MockRepositoryInterface) GetItemsWithContext(ctx context.Context, key djoemo.KeyInterface, out interface{}) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetItemsWithContext", ctx, key, out)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetItemsWithContext indicates an expected call of GetItemsWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) GetItemsWithContext(ctx, key, out interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemsWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).GetItemsWithContext), ctx, key, out)
}

// OptimisticLockSave mocks base method.
func (m *MockRepositoryInterface) OptimisticLockSave(key djoemo.KeyInterface, item interface{}) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OptimisticLockSave", key, item)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OptimisticLockSave indicates an expected call of OptimisticLockSave.
func (mr *MockRepositoryInterfaceMockRecorder) OptimisticLockSave(key, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OptimisticLockSave", reflect.TypeOf((*MockRepositoryInterface)(nil).OptimisticLockSave), key, item)
}

// OptimisticLockSaveWithContext mocks base method.
func (m *MockRepositoryInterface) OptimisticLockSaveWithContext(ctx context.Context, key djoemo.KeyInterface, item interface{}) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OptimisticLockSaveWithContext", ctx, key, item)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OptimisticLockSaveWithContext indicates an expected call of OptimisticLockSaveWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) OptimisticLockSaveWithContext(ctx, key, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OptimisticLockSaveWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).OptimisticLockSaveWithContext), ctx, key, item)
}

// Query mocks base method.
func (m *MockRepositoryInterface) Query(query djoemo.QueryInterface, item interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query", query, item)
	ret0, _ := ret[0].(error)
	return ret0
}

// Query indicates an expected call of Query.
func (mr *MockRepositoryInterfaceMockRecorder) Query(query, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockRepositoryInterface)(nil).Query), query, item)
}

// QueryWithContext mocks base method.
func (m *MockRepositoryInterface) QueryWithContext(ctx context.Context, query djoemo.QueryInterface, item interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryWithContext", ctx, query, item)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueryWithContext indicates an expected call of QueryWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) QueryWithContext(ctx, query, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).QueryWithContext), ctx, query, item)
}

// SaveItem mocks base method.
func (m *MockRepositoryInterface) SaveItem(key djoemo.KeyInterface, item interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveItem", key, item)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveItem indicates an expected call of SaveItem.
func (mr *MockRepositoryInterfaceMockRecorder) SaveItem(key, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveItem", reflect.TypeOf((*MockRepositoryInterface)(nil).SaveItem), key, item)
}

// SaveItemWithContext mocks base method.
func (m *MockRepositoryInterface) SaveItemWithContext(ctx context.Context, key djoemo.KeyInterface, item interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveItemWithContext", ctx, key, item)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveItemWithContext indicates an expected call of SaveItemWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) SaveItemWithContext(ctx, key, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveItemWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).SaveItemWithContext), ctx, key, item)
}

// SaveItems mocks base method.
func (m *MockRepositoryInterface) SaveItems(key djoemo.KeyInterface, items interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveItems", key, items)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveItems indicates an expected call of SaveItems.
func (mr *MockRepositoryInterfaceMockRecorder) SaveItems(key, items interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveItems", reflect.TypeOf((*MockRepositoryInterface)(nil).SaveItems), key, items)
}

// SaveItemsWithContext mocks base method.
func (m *MockRepositoryInterface) SaveItemsWithContext(ctx context.Context, key djoemo.KeyInterface, items interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveItemsWithContext", ctx, key, items)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveItemsWithContext indicates an expected call of SaveItemsWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) SaveItemsWithContext(ctx, key, items interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveItemsWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).SaveItemsWithContext), ctx, key, items)
}

// ScanIteratorWithContext mocks base method.
func (m *MockRepositoryInterface) ScanIteratorWithContext(ctx context.Context, key djoemo.KeyInterface, searchLimit int64) (djoemo.IteratorInterface, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScanIteratorWithContext", ctx, key, searchLimit)
	ret0, _ := ret[0].(djoemo.IteratorInterface)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScanIteratorWithContext indicates an expected call of ScanIteratorWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) ScanIteratorWithContext(ctx, key, searchLimit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanIteratorWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).ScanIteratorWithContext), ctx, key, searchLimit)
}

// Update mocks base method.
func (m *MockRepositoryInterface) Update(expression djoemo.UpdateExpression, key djoemo.KeyInterface, values map[string]interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", expression, key, values)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockRepositoryInterfaceMockRecorder) Update(expression, key, values interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockRepositoryInterface)(nil).Update), expression, key, values)
}

// UpdateWithContext mocks base method.
func (m *MockRepositoryInterface) UpdateWithContext(ctx context.Context, expression djoemo.UpdateExpression, key djoemo.KeyInterface, values map[string]interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWithContext", ctx, expression, key, values)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWithContext indicates an expected call of UpdateWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) UpdateWithContext(ctx, expression, key, values interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).UpdateWithContext), ctx, expression, key, values)
}

// UpdateWithUpdateExpressions mocks base method.
func (m *MockRepositoryInterface) UpdateWithUpdateExpressions(ctx context.Context, key djoemo.KeyInterface, updateExpressions djoemo.UpdateExpressions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWithUpdateExpressions", ctx, key, updateExpressions)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWithUpdateExpressions indicates an expected call of UpdateWithUpdateExpressions.
func (mr *MockRepositoryInterfaceMockRecorder) UpdateWithUpdateExpressions(ctx, key, updateExpressions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithUpdateExpressions", reflect.TypeOf((*MockRepositoryInterface)(nil).UpdateWithUpdateExpressions), ctx, key, updateExpressions)
}

// UpdateWithUpdateExpressionsAndReturnValue mocks base method.
func (m *MockRepositoryInterface) UpdateWithUpdateExpressionsAndReturnValue(ctx context.Context, key djoemo.KeyInterface, item interface{}, updateExpressions djoemo.UpdateExpressions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWithUpdateExpressionsAndReturnValue", ctx, key, item, updateExpressions)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWithUpdateExpressionsAndReturnValue indicates an expected call of UpdateWithUpdateExpressionsAndReturnValue.
func (mr *MockRepositoryInterfaceMockRecorder) UpdateWithUpdateExpressionsAndReturnValue(ctx, key, item, updateExpressions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithUpdateExpressionsAndReturnValue", reflect.TypeOf((*MockRepositoryInterface)(nil).UpdateWithUpdateExpressionsAndReturnValue), ctx, key, item, updateExpressions)
}

// WithLog mocks base method.
func (m *MockRepositoryInterface) WithLog(log djoemo.LogInterface) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WithLog", log)
}

// WithLog indicates an expected call of WithLog.
func (mr *MockRepositoryInterfaceMockRecorder) WithLog(log interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithLog", reflect.TypeOf((*MockRepositoryInterface)(nil).WithLog), log)
}

// WithMetrics mocks base method.
func (m *MockRepositoryInterface) WithMetrics(metricsInterface djoemo.MetricsInterface) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WithMetrics", metricsInterface)
}

// WithMetrics indicates an expected call of WithMetrics.
func (mr *MockRepositoryInterfaceMockRecorder) WithMetrics(metricsInterface interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithMetrics", reflect.TypeOf((*MockRepositoryInterface)(nil).WithMetrics), metricsInterface)
}
