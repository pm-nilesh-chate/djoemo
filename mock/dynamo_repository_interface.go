// Code generated by MockGen. DO NOT EDIT.
// Source: dynamo_repository_interface.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	djoemo "github.com/adjoeio/djoemo"
	prometheus "github.com/prometheus/client_golang/prometheus"
	"go.uber.org/mock/gomock"
)

// MockRepositoryInterface is a mock of RepositoryInterface interface.
type MockRepositoryInterface struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryInterfaceMockRecorder
}

// MockRepositoryInterfaceMockRecorder is the mock recorder for MockRepositoryInterface.
type MockRepositoryInterfaceMockRecorder struct {
	mock *MockRepositoryInterface
}

// NewMockRepositoryInterface creates a new mock instance.
func NewMockRepositoryInterface(ctrl *gomock.Controller) *MockRepositoryInterface {
	mock := &MockRepositoryInterface{ctrl: ctrl}
	mock.recorder = &MockRepositoryInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryInterface) EXPECT() *MockRepositoryInterfaceMockRecorder {
	return m.recorder
}

// BatchGetItemsWithContext mocks base method.
func (m *MockRepositoryInterface) BatchGetItemsWithContext(ctx context.Context, keys []djoemo.KeyInterface, out any) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BatchGetItemsWithContext", ctx, keys, out)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetItemsWithContext indicates an expected call of BatchGetItemsWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) BatchGetItemsWithContext(ctx, keys, out interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetItemsWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).BatchGetItemsWithContext), ctx, keys, out)
}

// ConditionalUpdateWithContext mocks base method.
func (m *MockRepositoryInterface) ConditionalUpdateWithContext(ctx context.Context, key djoemo.KeyInterface, item any, expression string, expressionArgs ...any) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, key, item, expression}
	for _, a := range expressionArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConditionalUpdateWithContext", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConditionalUpdateWithContext indicates an expected call of ConditionalUpdateWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) ConditionalUpdateWithContext(ctx, key, item, expression interface{}, expressionArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, key, item, expression}, expressionArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConditionalUpdateWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).ConditionalUpdateWithContext), varargs...)
}

// ConditionalUpdateWithUpdateExpressionsAndReturnValue mocks base method.
func (m *MockRepositoryInterface) ConditionalUpdateWithUpdateExpressionsAndReturnValue(ctx context.Context, key djoemo.KeyInterface, item any, updateExpressions djoemo.UpdateExpressions, conditionExpression string, conditionArgs ...any) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, key, item, updateExpressions, conditionExpression}
	for _, a := range conditionArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConditionalUpdateWithUpdateExpressionsAndReturnValue", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConditionalUpdateWithUpdateExpressionsAndReturnValue indicates an expected call of ConditionalUpdateWithUpdateExpressionsAndReturnValue.
func (mr *MockRepositoryInterfaceMockRecorder) ConditionalUpdateWithUpdateExpressionsAndReturnValue(ctx, key, item, updateExpressions, conditionExpression interface{}, conditionArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, key, item, updateExpressions, conditionExpression}, conditionArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConditionalUpdateWithUpdateExpressionsAndReturnValue", reflect.TypeOf((*MockRepositoryInterface)(nil).ConditionalUpdateWithUpdateExpressionsAndReturnValue), varargs...)
}

// DeleteItemWithContext mocks base method.
func (m *MockRepositoryInterface) DeleteItemWithContext(ctx context.Context, key djoemo.KeyInterface) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteItemWithContext", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteItemWithContext indicates an expected call of DeleteItemWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) DeleteItemWithContext(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteItemWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).DeleteItemWithContext), ctx, key)
}

// DeleteItemsWithContext mocks base method.
func (m *MockRepositoryInterface) DeleteItemsWithContext(ctx context.Context, key []djoemo.KeyInterface) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteItemsWithContext", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteItemsWithContext indicates an expected call of DeleteItemsWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) DeleteItemsWithContext(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteItemsWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).DeleteItemsWithContext), ctx, key)
}

// GIndex mocks base method.
func (m *MockRepositoryInterface) GIndex(name string) djoemo.GlobalIndexInterface {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GIndex", name)
	ret0, _ := ret[0].(djoemo.GlobalIndexInterface)
	return ret0
}

// GIndex indicates an expected call of GIndex.
func (mr *MockRepositoryInterfaceMockRecorder) GIndex(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GIndex", reflect.TypeOf((*MockRepositoryInterface)(nil).GIndex), name)
}

// GetItemWithContext mocks base method.
func (m *MockRepositoryInterface) GetItemWithContext(ctx context.Context, key djoemo.KeyInterface, item any) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetItemWithContext", ctx, key, item)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetItemWithContext indicates an expected call of GetItemWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) GetItemWithContext(ctx, key, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).GetItemWithContext), ctx, key, item)
}

// GetItemsWithContext mocks base method.
func (m *MockRepositoryInterface) GetItemsWithContext(ctx context.Context, key djoemo.KeyInterface, out any) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetItemsWithContext", ctx, key, out)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetItemsWithContext indicates an expected call of GetItemsWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) GetItemsWithContext(ctx, key, out interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemsWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).GetItemsWithContext), ctx, key, out)
}

// OptimisticLockSaveWithContext mocks base method.
func (m *MockRepositoryInterface) OptimisticLockSaveWithContext(ctx context.Context, key djoemo.KeyInterface, item any) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OptimisticLockSaveWithContext", ctx, key, item)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OptimisticLockSaveWithContext indicates an expected call of OptimisticLockSaveWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) OptimisticLockSaveWithContext(ctx, key, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OptimisticLockSaveWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).OptimisticLockSaveWithContext), ctx, key, item)
}

// QueryWithContext mocks base method.
func (m *MockRepositoryInterface) QueryWithContext(ctx context.Context, query djoemo.QueryInterface, item any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryWithContext", ctx, query, item)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueryWithContext indicates an expected call of QueryWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) QueryWithContext(ctx, query, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).QueryWithContext), ctx, query, item)
}

// SaveItemWithContext mocks base method.
func (m *MockRepositoryInterface) SaveItemWithContext(ctx context.Context, key djoemo.KeyInterface, item any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveItemWithContext", ctx, key, item)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveItemWithContext indicates an expected call of SaveItemWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) SaveItemWithContext(ctx, key, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveItemWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).SaveItemWithContext), ctx, key, item)
}

// SaveItemsWithContext mocks base method.
func (m *MockRepositoryInterface) SaveItemsWithContext(ctx context.Context, key djoemo.KeyInterface, items any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveItemsWithContext", ctx, key, items)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveItemsWithContext indicates an expected call of SaveItemsWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) SaveItemsWithContext(ctx, key, items interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveItemsWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).SaveItemsWithContext), ctx, key, items)
}

// ScanIteratorWithContext mocks base method.
func (m *MockRepositoryInterface) ScanIteratorWithContext(ctx context.Context, key djoemo.KeyInterface, searchLimit int64) (djoemo.IteratorInterface, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScanIteratorWithContext", ctx, key, searchLimit)
	ret0, _ := ret[0].(djoemo.IteratorInterface)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScanIteratorWithContext indicates an expected call of ScanIteratorWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) ScanIteratorWithContext(ctx, key, searchLimit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanIteratorWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).ScanIteratorWithContext), ctx, key, searchLimit)
}

// UpdateWithContext mocks base method.
func (m *MockRepositoryInterface) UpdateWithContext(ctx context.Context, expression djoemo.UpdateExpression, key djoemo.KeyInterface, values map[string]any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWithContext", ctx, expression, key, values)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWithContext indicates an expected call of UpdateWithContext.
func (mr *MockRepositoryInterfaceMockRecorder) UpdateWithContext(ctx, expression, key, values interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithContext", reflect.TypeOf((*MockRepositoryInterface)(nil).UpdateWithContext), ctx, expression, key, values)
}

// UpdateWithUpdateExpressions mocks base method.
func (m *MockRepositoryInterface) UpdateWithUpdateExpressions(ctx context.Context, key djoemo.KeyInterface, updateExpressions djoemo.UpdateExpressions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWithUpdateExpressions", ctx, key, updateExpressions)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWithUpdateExpressions indicates an expected call of UpdateWithUpdateExpressions.
func (mr *MockRepositoryInterfaceMockRecorder) UpdateWithUpdateExpressions(ctx, key, updateExpressions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithUpdateExpressions", reflect.TypeOf((*MockRepositoryInterface)(nil).UpdateWithUpdateExpressions), ctx, key, updateExpressions)
}

// UpdateWithUpdateExpressionsAndReturnValue mocks base method.
func (m *MockRepositoryInterface) UpdateWithUpdateExpressionsAndReturnValue(ctx context.Context, key djoemo.KeyInterface, item any, updateExpressions djoemo.UpdateExpressions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWithUpdateExpressionsAndReturnValue", ctx, key, item, updateExpressions)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWithUpdateExpressionsAndReturnValue indicates an expected call of UpdateWithUpdateExpressionsAndReturnValue.
func (mr *MockRepositoryInterfaceMockRecorder) UpdateWithUpdateExpressionsAndReturnValue(ctx, key, item, updateExpressions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithUpdateExpressionsAndReturnValue", reflect.TypeOf((*MockRepositoryInterface)(nil).UpdateWithUpdateExpressionsAndReturnValue), ctx, key, item, updateExpressions)
}

// WithLog mocks base method.
func (m *MockRepositoryInterface) WithLog(log djoemo.LogInterface) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WithLog", log)
}

// WithLog indicates an expected call of WithLog.
func (mr *MockRepositoryInterfaceMockRecorder) WithLog(log interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithLog", reflect.TypeOf((*MockRepositoryInterface)(nil).WithLog), log)
}

// WithMetrics mocks base method.
func (m *MockRepositoryInterface) WithMetrics(metricsInterface djoemo.MetricsInterface) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WithMetrics", metricsInterface)
}

// WithMetrics indicates an expected call of WithMetrics.
func (mr *MockRepositoryInterfaceMockRecorder) WithMetrics(metricsInterface interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithMetrics", reflect.TypeOf((*MockRepositoryInterface)(nil).WithMetrics), metricsInterface)
}

// WithPrometheusMetrics mocks base method.
func (m *MockRepositoryInterface) WithPrometheusMetrics(registry *prometheus.Registry) djoemo.RepositoryInterface {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithPrometheusMetrics", registry)
	ret0, _ := ret[0].(djoemo.RepositoryInterface)
	return ret0
}

// WithPrometheusMetrics indicates an expected call of WithPrometheusMetrics.
func (mr *MockRepositoryInterfaceMockRecorder) WithPrometheusMetrics(registry interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithPrometheusMetrics", reflect.TypeOf((*MockRepositoryInterface)(nil).WithPrometheusMetrics), registry)
}
